// -*- rust -*-

use std::str::FromStr;
use crate::ast::{Expr, BinOpcode, NumSource};
use crate::util;

use lalrpop_util::ParseError;

grammar<'input>(input: &'input str);

pub TopLevel: Box<Expr> = {
    Term,
    <Term> ! => Box::new(Expr::BadParse(<>)),
}

pub Term: Box<Expr> = Term2;

Term2: Box<Expr> = {
    Term1,
    <a:Term2> "*" <b:Term1> => Box::new(Expr::BinOp(BinOpcode::Mul, a, b)),
}

Term1: Box<Expr> = {
    Val,
    <a:Term1> "+" <b:Val> => Box::new(Expr::BinOp(BinOpcode::Add, a, b)),
    <a:Term1> "-" <b:Val> => Box::new(Expr::BinOp(BinOpcode::Sub, a, b)),
    "(" <t:Term> ")" => t,
};

Val: Box<Expr> = {
    NumExpr,
    NumWordsExpr,
    Var => Box::new(Expr::Var(String::from(<>))),
}

NumExpr: Box<Expr> =
    <Digits> => Box::new(Expr::Number(<>, NumSource::Digits));

NumWordsExpr: Box<Expr> =
    <NumWords> => Box::new(Expr::Number(<>, NumSource::Words));

// -- NumWords

Digit: i64 = {
    "zero" => 0,
    "one" => 1,
    "two" => 2,
    "three" => 3,
    "four" => 4,
    "five" => 5,
    "six" => 6,
    "seven" => 7,
    "eight" => 8,
    "nine" => 9
}

Tens: i64 = {
    "twenty" => 20,
    "thirty" => 30,
    "forty" => 40,
    "fifty" => 50,
    "sixty" => 60,
    "seventy" => 70,
    "eighty" => 80,
    "ninety" => 90,
}

Teens: i64 = {
    "ten" => 10,
    "eleven" => 11,
    "twelve" => 12,
    "thirteen" => 13,
    "fourteen" => 14,
    "fifteen" => 15,
    "sixteen" => 16,
    "seventeen" => 17,
    "eighteen" => 18,
    "nineteen" => 19,
}

BigMagnitude: i64 = {
    "thousand" => 1_000,
    "million" => 1_000_000,
    "billion" => 1_000_000_000,
    "trillion" => 1_000_000_000_000,
}

FullTens: i64 = {
    <tens:Tens?> <ones:Digit> => tens.unwrap_or(0) + ones,
    <tens:Tens> => tens,
    <Teens> => <>,
}

pub ThousandsGroup: i64 = {
    <hundreds: (<Digit> "hundred")?> <tens:FullTens> =>
        hundreds.map_or(0, |v| v*100) + tens,
}

// Returns the number, and the largest encountered magnitude
NumWordsGroups: (i64, i64) = {
    <ts:ThousandsGroup> <mag:BigMagnitude?> => {
        let mag1 = mag.unwrap_or(1);
        (ts * mag1, mag1)
    },
    <ts:ThousandsGroup> <mag:BigMagnitude> <rest:NumWordsGroups> =>? {
        let (vrest, magrest) = rest;
        if mag <= magrest {
            return Err(ParseError::User
                       { error: "Magnitudes must descend".to_string() });
        }
        Ok((ts * mag + vrest, mag))
    }
};

pub NumWords: i64 = <NumWordsGroups> => <>.0;

extern {
    type Location = usize;
    type Error = String;

    enum util::Token<'input> {
        "+" => util::Token::Plus,
        "-" => util::Token::Minus,
        "*" => util::Token::Times,

        "(" => util::Token::LParen,
        ")" => util::Token::RParen,

        Digits => util::Token::Digits(<i64>),
        Var => util::Token::Var(<&'input str>),

    // #[error]
    // #[regex(r"\s+", logos::skip)]
    // Unknown,

        "zero" => util::Token::Zero,
        "one" => util::Token::One,
        "two" => util::Token::Two,
        "three" => util::Token::Three,
        "four" => util::Token::Four,
        "five" => util::Token::Five,
        "six" => util::Token::Six,
        "seven" => util::Token::Seven,
        "eight" => util::Token::Eight,
        "nine" => util::Token::Nine,
        "ten" => util::Token::Ten,
        "eleven" => util::Token::Eleven,
        "twelve" => util::Token::Twelve,
        "thirteen" => util::Token::Thirteen,
        "fourteen" => util::Token::Fourteen,
        "fifteen" => util::Token::Fifteen,
        "sixteen" => util::Token::Sixteen,
        "seventeen" => util::Token::Seventeen,
        "eighteen" => util::Token::Eighteen,
        "nineteen" => util::Token::Nineteen,
        "twenty" => util::Token::Twenty,
        "thirty" => util::Token::Thirty,
        "forty" => util::Token::Forty,
        "fifty" => util::Token::Fifty,
        "sixty" => util::Token::Sixty,
        "seventy" => util::Token::Seventy,
        "eighty" => util::Token::Eighty,
        "ninety" => util::Token::Ninety,
        "hundred" => util::Token::Hundred,
        "thousand" => util::Token::Thousand,
        "million" => util::Token::Million,
        "billion" => util::Token::Billion,
        "trillion" => util::Token::Trillion,
    }
}
