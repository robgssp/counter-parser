// -*- rust -*-

use crate::ast::{Expr, Node, BinOpcode, UnaOpcode, NumSource, Num, to_num};
use crate::util;

use lalrpop_util::ParseError;

grammar<'input>(input: &'input str);

pub TopLevel: Expr = {
    AnyFix,
    <AnyFix> ! => Box::new(Node::BadParse(<>)),
}

AnyFix: Expr = {
    Term,
    PostOpTop,
    PreOpTop,
}

// Infix ops
pub Term: Expr = Term1;

BinOpLeft<Ops, Higher>: Expr = {
    Higher,
    <a:BinOpLeft<Ops, Higher>> <op:Ops> <b:Higher> =>
        Box::new(Node::BinOp(op, a, b)),
}

BinOpRight<Ops, Higher>: Expr = {
    Higher,
    <a:Higher> <op:Ops> <b:BinOpRight<Ops, Higher>> =>
        Box::new(Node::BinOp(op, a, b)),
}

Term8Op: BinOpcode = "|" => BinOpcode::Or;
Term8: Expr = BinOpLeft<Term8Op, Val>;

Term7Op: BinOpcode = "xor" => BinOpcode::Xor;
Term7: Expr = BinOpLeft<Term7Op, Term8>;

Term6Op: BinOpcode = "&" => BinOpcode::And;
Term6: Expr = BinOpLeft<Term6Op, Term7>;

Term5Op: BinOpcode = {
    ">>" => BinOpcode::RShift,
    "<<" => BinOpcode::LShift,
}
Term5: Expr = BinOpLeft<Term5Op, Term6>;

Term4: Expr = {
    Term5,
    <a:Term5> "!" => Box::new(Node::UnaOp(UnaOpcode::Factorial, a)),
}

Term3Op: BinOpcode = "^" => BinOpcode::Exp;
Term3: Expr = BinOpRight<Term3Op, Term4>;

Term2Op: BinOpcode = {
    "*" => BinOpcode::Mul,
    "/" => BinOpcode::Div,
}
Term2: Expr = BinOpLeft<Term2Op, Term3>;

Term1Op: BinOpcode = {
    "+" => BinOpcode::Add,
    "-" => BinOpcode::Sub,
}
Term1: Expr = BinOpLeft<Term1Op, Term2>;

Val: Expr = {
    NumExpr,
    Roll => Box::new(Node::Roll(<>.0, <>.1)),
    NumWordsExpr,
    Var => Box::new(Node::Var(String::from(<>))),
    "(" <t:AnyFix> ")" => t,
}

// Postfix ops

BinOp: BinOpcode = {
    Term1Op, Term2Op, Term3Op, Term5Op, Term6Op, Term7Op, Term8Op
}

PostOp: Expr = {
    PostVal, PostOpTop
}

PostOpTop: Expr = {
    <a:PostOp> <b:PostOp> <op:BinOp> => Box::new(Node::BinOp(op, a, b)),
}

PostVal: Expr = {
    NumExpr,
    Roll => Box::new(Node::Roll(<>.0, <>.1)),
    Var => Box::new(Node::Var(String::from(<>))),
    "(" <t:AnyFix> ")" => t,
}

// Prefix ops

PreOp: Expr = {
    PostVal, PreOpTop
}

PreOpTop: Expr = {
    <op:BinOp> <a:PreOp> <b:PreOp> => Box::new(Node::BinOp(op, a, b))
}

// Common
NumExpr: Expr =
    <Digits> => Box::new(Node::Number(<>, NumSource::Digits));

NumWordsExpr: Expr =
    <NumWords> => Box::new(Node::Number(<>, NumSource::Words));

// -- NumWords

Digit: Num = {
    "zero" => to_num(0),
    "one" => to_num(1),
    "two" => to_num(2),
    "three" => to_num(3),
    "four" => to_num(4),
    "five" => to_num(5),
    "six" => to_num(6),
    "seven" => to_num(7),
    "eight" => to_num(8),
    "nine" => to_num(9)
}

Tens: Num = {
    "twenty" => to_num(20),
    "thirty" => to_num(30),
    "forty" => to_num(40),
    "fifty" => to_num(50),
    "sixty" => to_num(60),
    "seventy" => to_num(70),
    "eighty" => to_num(80),
    "ninety" => to_num(90),
}

Teens: Num = {
    "ten" => to_num(10),
    "eleven" => to_num(11),
    "twelve" => to_num(12),
    "thirteen" => to_num(13),
    "fourteen" => to_num(14),
    "fifteen" => to_num(15),
    "sixteen" => to_num(16),
    "seventeen" => to_num(17),
    "eighteen" => to_num(18),
    "nineteen" => to_num(19),
}

BigMagnitude: Num = {
    "thousand" => to_num(1_000),
    "million" => to_num(1_000_000),
    "billion" => to_num(1_000_000_000),
    "trillion" => to_num(1_000_000_000_000),
}

FullTens: Num = {
    <tens:Tens?> <ones:Digit> => tens.unwrap_or(to_num(0)) + ones,
    <tens:Tens> => tens,
    <Teens> => <>,
}

pub ThousandsGroup: Num = {
    <hundreds: (<Digit> "hundred")?> <tens:FullTens> =>
        hundreds.map_or(to_num(0), |v| v*to_num(100)) + tens,
    <hundreds:Digit> "hundred" =>
        hundreds * to_num(100),
}

// Returns the number, and the largest encountered magnitude
NumWordsGroups: (Num, Num) = {
    <ts:ThousandsGroup> <mag:BigMagnitude?> => {
        let mag1 = mag.unwrap_or(to_num(1));
        (ts * &mag1, mag1)
    },
    <ts:ThousandsGroup> <mag:BigMagnitude> <rest:NumWordsGroups> =>? {
        let (vrest, magrest) = rest;
        if mag <= magrest {
            return Err(ParseError::User
                       { error: "Magnitudes must descend".to_string() });
        }
        Ok((ts * &mag + vrest, mag))
    }
};

pub NumWords: Num = <NumWordsGroups> => <>.0;

extern {
    type Location = usize;
    type Error = String;

    enum util::Token<'input> {
        "+" => util::Token::Plus,
        "-" => util::Token::Minus,
        "*" => util::Token::Times,
        "/" => util::Token::Slash,
        "^" => util::Token::Hat,
        "!" => util::Token::Excl,
        "(" => util::Token::LParen,
        ")" => util::Token::RParen,
        "&" => util::Token::And,
        "|" => util::Token::Or,
        "xor" => util::Token::Xor,
        "<<" => util::Token::LShift,
        ">>" => util::Token::RShift,

        Digits => util::Token::Digits(<Num>),
        Roll => util::Token::Roll(<(i64, i64)>),
        Var => util::Token::Var(<&'input str>),

        "zero" => util::Token::Zero,
        "one" => util::Token::One,
        "two" => util::Token::Two,
        "three" => util::Token::Three,
        "four" => util::Token::Four,
        "five" => util::Token::Five,
        "six" => util::Token::Six,
        "seven" => util::Token::Seven,
        "eight" => util::Token::Eight,
        "nine" => util::Token::Nine,
        "ten" => util::Token::Ten,
        "eleven" => util::Token::Eleven,
        "twelve" => util::Token::Twelve,
        "thirteen" => util::Token::Thirteen,
        "fourteen" => util::Token::Fourteen,
        "fifteen" => util::Token::Fifteen,
        "sixteen" => util::Token::Sixteen,
        "seventeen" => util::Token::Seventeen,
        "eighteen" => util::Token::Eighteen,
        "nineteen" => util::Token::Nineteen,
        "twenty" => util::Token::Twenty,
        "thirty" => util::Token::Thirty,
        "forty" => util::Token::Forty,
        "fifty" => util::Token::Fifty,
        "sixty" => util::Token::Sixty,
        "seventy" => util::Token::Seventy,
        "eighty" => util::Token::Eighty,
        "ninety" => util::Token::Ninety,
        "hundred" => util::Token::Hundred,
        "thousand" => util::Token::Thousand,
        "million" => util::Token::Million,
        "billion" => util::Token::Billion,
        "trillion" => util::Token::Trillion,

        Unknown => util::Token::Unknown,
    }
}
