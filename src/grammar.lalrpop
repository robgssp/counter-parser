// -*- rust -*-

use std::str::FromStr;
use crate::ast::{Expr, BinOpcode, NumSource};

use lalrpop_util::ParseError;

grammar;

pub TopLevel: Box<Expr> = {
    Term,
    <Term> ! => Box::new(Expr::BadParse(<>)),
}

pub Term: Box<Expr> = {
    Val,
    <a:Term> "+" <b:NumExpr> => Box::new(Expr::BinOp(BinOpcode::Add, a, b)),
    "(" <t:Term> ")" => t,
};

Val: Box<Expr> = {
    NumExpr,
    NumWordsExpr,
    <r"[a-zA-Z][a-zA-Z0-9_]*"> => Box::new(Expr::Var(String::from(<>))),
}

NumExpr: Box<Expr> =
    <Num> => Box::new(Expr::Number(<>, NumSource::Digits));

Num: i64 = <s:r"[0-9]+"> => i64::from_str(s).unwrap();

NumWordsExpr: Box<Expr> = {
    <NumWords> => Box::new(Expr::Number(
        <>,
        NumSource::Words)),
};


// -- NumWords

Digit: i64 = {
    "zero" => 0,
    "one" => 1,
    "two" => 2,
    "three" => 3,
    "four" => 4,
    "five" => 5,
    "six" => 6,
    "seven" => 7,
    "eight" => 8,
    "nine" => 9
}

Tens: i64 = {
    "twenty" => 20,
    "thirty" => 30,
    "forty" => 40,
    "fifty" => 50,
    "sixty" => 60,
    "seventy" => 70,
    "eighty" => 80,
    "ninety" => 90,
}

Teens: i64 = {
    "ten" => 10,
    "eleven" => 11,
    "twelve" => 12,
    "thirteen" => 13,
    "fourteen" => 14,
    "fifteen" => 15,
    "sixteen" => 16,
    "seventeen" => 17,
    "eighteen" => 18,
    "nineteen" => 19,
}

BigMagnitude: i64 = {
    "thousand" => 1_000,
    "million" => 1_000_000,
    "billion" => 1_000_000_000,
    "trillion" => 1_000_000_000_000,
}

FullTens: i64 = {
    <tens:(<Tens>)?> <ones:Digit> => tens.unwrap_or(0) + ones,
    <tens:Tens> => tens,
    <Teens> => <>,
}

pub ThousandsGroup: i64 = {
    <hundreds: (<Digit> "hundred")?> <tens:FullTens> =>
        hundreds.map_or(0, |v| v*100) + tens,
}

// Returns the number, and the largest encountered magnitude
NumWordsGroups: (i64, i64) = {
    <ts:ThousandsGroup> <mag:(<BigMagnitude>)?> => {
        let mag1 = mag.unwrap_or(1);
        (ts * mag1, mag1)
    },
    <ts:ThousandsGroup> <mag:BigMagnitude> <rest:NumWordsGroups> =>? {
        let (vrest, magrest) = rest;
        if mag <= magrest {
            return Err(ParseError::User { error: "Magnitudes must descend" });
        }
        Ok((ts * mag + vrest, mag))
    }
};

pub NumWords: i64 = <NumWordsGroups> => <>.0;

// -- Other

// TODO testing purposes only
pub MiddleString: &'input str = {
    "a" <"b"> "c" => <>,
}
