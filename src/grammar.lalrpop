// -*- rust -*-

use crate::ast::{Expr, Node, BinOpcode, UnaOpcode, NumSource, Num, to_num};
use crate::util;

use lalrpop_util::ParseError;

grammar<'input>(input: &'input str);

pub TopLevel: Expr = {
    Term,
    <Term> ! => Box::new(Node::BadParse(<>)),
}

pub Term: Expr = Term1;

Term2Op: BinOpcode = {
    "*" => BinOpcode::Mul,
    "/" => BinOpcode::Div,
}

Term3: Expr = {
    Val,
    <a:Val> "!" => Box::new(Node::UnaOp(UnaOpcode::Factorial, a)),
}

Term2: Expr = {
    Term3,
    <a:Term2> <op:Term2Op> <b:Term3> => Box::new(Node::BinOp(op, a, b)),
//     <a:Term2> Term2Op ! => Box::new(Node::BadParse(a)),
}

Term1Op: BinOpcode = {
    "+" => BinOpcode::Add,
    "-" => BinOpcode::Sub,
}

Term1: Expr = {
    Term2,
    <a:Term1> <op:Term1Op> <b:Term2> => Box::new(Node::BinOp(op, a, b)),
//     <a:Term1> Term1Op ! => Box::new(Node::BadParse(a)),
};

Val: Expr = {
    NumExpr,
    Roll => Box::new(Node::Roll(<>.0, <>.1)),
    NumWordsExpr,
    Var => Box::new(Node::Var(String::from(<>))),
    "(" <t:Term> ")" => t,
}

NumExpr: Expr =
    <Digits> => Box::new(Node::Number(<>, NumSource::Digits));

NumWordsExpr: Expr =
    <NumWords> => Box::new(Node::Number(<>, NumSource::Words));

// -- NumWords

Digit: Num = {
    "zero" => to_num(0),
    "one" => to_num(1),
    "two" => to_num(2),
    "three" => to_num(3),
    "four" => to_num(4),
    "five" => to_num(5),
    "six" => to_num(6),
    "seven" => to_num(7),
    "eight" => to_num(8),
    "nine" => to_num(9)
}

Tens: Num = {
    "twenty" => to_num(20),
    "thirty" => to_num(30),
    "forty" => to_num(40),
    "fifty" => to_num(50),
    "sixty" => to_num(60),
    "seventy" => to_num(70),
    "eighty" => to_num(80),
    "ninety" => to_num(90),
}

Teens: Num = {
    "ten" => to_num(10),
    "eleven" => to_num(11),
    "twelve" => to_num(12),
    "thirteen" => to_num(13),
    "fourteen" => to_num(14),
    "fifteen" => to_num(15),
    "sixteen" => to_num(16),
    "seventeen" => to_num(17),
    "eighteen" => to_num(18),
    "nineteen" => to_num(19),
}

BigMagnitude: Num = {
    "thousand" => to_num(1_000),
    "million" => to_num(1_000_000),
    "billion" => to_num(1_000_000_000),
    "trillion" => to_num(1_000_000_000_000),
}

FullTens: Num = {
    <tens:Tens?> <ones:Digit> => tens.unwrap_or(to_num(0)) + ones,
    <tens:Tens> => tens,
    <Teens> => <>,
}

pub ThousandsGroup: Num = {
    <hundreds: (<Digit> "hundred")?> <tens:FullTens> =>
        hundreds.map_or(to_num(0), |v| v*to_num(100)) + tens,
}

// Returns the number, and the largest encountered magnitude
NumWordsGroups: (Num, Num) = {
    <ts:ThousandsGroup> <mag:BigMagnitude?> => {
        let mag1 = mag.unwrap_or(to_num(1));
        (ts * &mag1, mag1)
    },
    <ts:ThousandsGroup> <mag:BigMagnitude> <rest:NumWordsGroups> =>? {
        let (vrest, magrest) = rest;
        if mag <= magrest {
            return Err(ParseError::User
                       { error: "Magnitudes must descend".to_string() });
        }
        Ok((ts * &mag + vrest, mag))
    }
};

pub NumWords: Num = <NumWordsGroups> => <>.0;

extern {
    type Location = usize;
    type Error = String;

    enum util::Token<'input> {
        "+" => util::Token::Plus,
        "-" => util::Token::Minus,
        "*" => util::Token::Times,
        "/" => util::Token::Slash,
        "^" => util::Token::Hat,
        "!" => util::Token::Excl,
        "(" => util::Token::LParen,
        ")" => util::Token::RParen,

        Digits => util::Token::Digits(<Num>),
        Roll => util::Token::Roll(<(i64, i64)>),
        Var => util::Token::Var(<&'input str>),

        "zero" => util::Token::Zero,
        "one" => util::Token::One,
        "two" => util::Token::Two,
        "three" => util::Token::Three,
        "four" => util::Token::Four,
        "five" => util::Token::Five,
        "six" => util::Token::Six,
        "seven" => util::Token::Seven,
        "eight" => util::Token::Eight,
        "nine" => util::Token::Nine,
        "ten" => util::Token::Ten,
        "eleven" => util::Token::Eleven,
        "twelve" => util::Token::Twelve,
        "thirteen" => util::Token::Thirteen,
        "fourteen" => util::Token::Fourteen,
        "fifteen" => util::Token::Fifteen,
        "sixteen" => util::Token::Sixteen,
        "seventeen" => util::Token::Seventeen,
        "eighteen" => util::Token::Eighteen,
        "nineteen" => util::Token::Nineteen,
        "twenty" => util::Token::Twenty,
        "thirty" => util::Token::Thirty,
        "forty" => util::Token::Forty,
        "fifty" => util::Token::Fifty,
        "sixty" => util::Token::Sixty,
        "seventy" => util::Token::Seventy,
        "eighty" => util::Token::Eighty,
        "ninety" => util::Token::Ninety,
        "hundred" => util::Token::Hundred,
        "thousand" => util::Token::Thousand,
        "million" => util::Token::Million,
        "billion" => util::Token::Billion,
        "trillion" => util::Token::Trillion,

        Unknown => util::Token::Unknown,
    }
}
